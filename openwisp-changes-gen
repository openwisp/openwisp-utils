#!/bin/bash

SKIP_CHANGELOG_FLAG="[skip changelog]"
CHANGES_FILE="CHANGES.rst"

function print_info() {
    echo -e "\033[1;34m[INFO]\033[0m $1"
}
function print_success() {
    echo -e "\033[1;32m[SUCCESS]\033[0m $1"
}
function print_warning() {
    echo -e "\033[1;33m[WARNING]\033[0m $1"
}
function print_error() {
    echo -e "\033[1;31m[ERROR]\033[0m $1"
    exit 1
}
function format_commit_message() {
    # Helps to standardize commit messages by removing prefixes
    # e.g., '[feature] msg', 'feature: msg', '[fix:ui] msg'
    echo "$1" | sed -E -e 's/^\[?[a-zA-Z!]+(:[^]]+)?\]?:? //'
}

print_info "Starting the release process..."
git fetch --tags
PREVIOUS_VERSION=$(git tag --sort=-taggerdate | head -n 1)

if [ -z "$PREVIOUS_VERSION" ]; then
    print_warning "No previous git tag found. Will generate changelog from the first commit."
    PREVIOUS_VERSION=$(git rev-list --max-parents=0 HEAD)
fi

print_info "The last detected version is: $PREVIOUS_VERSION"
read -r -p "Please enter the new version number (e.g., 1.2.0): " NEW_VERSION

if [ -z "$NEW_VERSION" ]; then
    print_error "Version number cannot be empty."
fi

print_info "Preparing release for version: $NEW_VERSION"
print_info "Generating changelog from git commits between $PREVIOUS_VERSION and HEAD..."

COMMIT_SEPARATOR="--COMMIT-END--"
COMMIT_LOG=$(git log --reverse --no-merges --pretty=format:"%s%n%b%n${COMMIT_SEPARATOR}" "${PREVIOUS_VERSION}"..HEAD)

# All sections
FEATURES=""
BACKWARD_INCOMPATIBLE_CHANGES=""
REGULAR_CHANGES=""
FIXES=""

# To handle duplicate and other deps prefixes
declare -A DEDUPED_DEPS
OTHER_DEPS=()

TEMP_LOG_FILE=$(mktemp)
echo "$COMMIT_LOG" > "$TEMP_LOG_FILE"

while IFS= read -r line; do
    full_commit_message="$line"
    while IFS= read -r next_line && [[ "$next_line" != "$COMMIT_SEPARATOR" ]]; do
        full_commit_message="$full_commit_message\n$next_line"
    done

    if echo "$full_commit_message" | grep -q -F "$SKIP_CHANGELOG_FLAG"; then
        continue
    fi

    subject=$(echo -e "$full_commit_message" | head -n 1)
    
    formatted_message=$(format_commit_message "$subject")

    # Use multi-pattern case to handle all conventions
    case "$subject" in
        '[feature'* | 'feature:'*)
            FEATURES+="- ${formatted_message}\n"
            ;;
        '[change!'* | 'change!:'*)
            BACKWARD_INCOMPATIBLE_CHANGES+="- ${formatted_message}\n"
            ;;
        '[change'* | 'change:'*)
            REGULAR_CHANGES+="- ${formatted_message}\n"
            ;;
        '[fix'* | 'fix:'*)
            FIXES+="- ${formatted_message}\n"
            ;;
        '[deps'* | 'deps:'*)
            if [[ "$formatted_message" == "Update "*" requirement from "*" to "*"" ]]; then
                package_name=$(echo "$formatted_message" | awk '{print $2}')
                version_string=$(echo "$formatted_message" | sed 's/.* to //')
                formatted_line="Bumped \`\`"
                formatted_line+="${package_name}${version_string}"
                formatted_line+="\`\`"
                DEDUPED_DEPS["$package_name"]="$formatted_line"
            else
                OTHER_DEPS+=("$formatted_message")
            fi
            ;;
    esac
done < "$TEMP_LOG_FILE"
rm "$TEMP_LOG_FILE"


DEPS=""
for key in $(echo "${!DEDUPED_DEPS[@]}" | tr ' ' '\n' | sort); do
    DEPS+="- ${DEDUPED_DEPS[$key]}\n"
done
for line in "${OTHER_DEPS[@]}"; do
    DEPS+="- ${line}\n"
done

NEW_CHANGELOG_BODY=""
# 1. Features
if [ -n "$FEATURES" ]; then
    NEW_CHANGELOG_BODY+="Features\n~~~~~~~~\n\n${FEATURES}"
fi
# 2. Changes
if [ -n "$BACKWARD_INCOMPATIBLE_CHANGES" ] || [ -n "$REGULAR_CHANGES" ] || [ -n "$DEPS" ]; then
    if [ -n "$NEW_CHANGELOG_BODY" ]; then NEW_CHANGELOG_BODY+="\n"; fi
    NEW_CHANGELOG_BODY+="Changes\n~~~~~~~\n\n"
    if [ -n "$BACKWARD_INCOMPATIBLE_CHANGES" ]; then
        NEW_CHANGELOG_BODY+="Backward incompatible changes\n+++++++++++++++++++++++++++++\n\n${BACKWARD_INCOMPATIBLE_CHANGES}\n"
    fi
    if [ -n "$REGULAR_CHANGES" ]; then
        if [ -n "$BACKWARD_INCOMPATIBLE_CHANGES" ]; then
            NEW_CHANGELOG_BODY+="Other changes\n+++++++++++++\n\n"
        fi
        NEW_CHANGELOG_BODY+="${REGULAR_CHANGES}\n"
    fi
    if [ -n "$DEPS" ]; then
        NEW_CHANGELOG_BODY+="Dependencies\n++++++++++++\n\n${DEPS}"
    fi
fi
# 3. Bugfixes
if [ -n "$FIXES" ]; then
    NEW_CHANGELOG_BODY+="\nBugfixes\n~~~~~~~~\n\n${FIXES}"
fi

if [ -z "$NEW_CHANGELOG_BODY" ]; then
    print_warning "No new changelog entries found matching the prefixes. Exiting."
    exit 0
fi

print_info "Generated changelog content. Now updating $CHANGES_FILE..."

TODAY_DATE=$(date +%Y-%m-%d)
NEW_VERSION_HEADER="Version $NEW_VERSION [$TODAY_DATE]\n--------------------------"
FINAL_CONTENT="${NEW_VERSION_HEADER}\n\n${NEW_CHANGELOG_BODY}"

# Safely updates the file in place by using a temporary file.
{
    echo "Changelog"
    echo "========="
    echo ""
    echo -e "$FINAL_CONTENT"
    tail -n +3 "$CHANGES_FILE"
} > "${CHANGES_FILE}.new" && mv "${CHANGES_FILE}.new" "$CHANGES_FILE"

print_success "$CHANGES_FILE has been updated."

print_info "Running QA formatter on the updated changelog..."
print_success "Changelog generation complete."

if openwisp-qa-format > /dev/null 2>&1; then
    print_success "openwisp-qa-format ran successfully."
else
    print_error "openwisp-qa-format failed to run."
fi
