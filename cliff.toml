# cliff.toml - Git-cliff configuration for OpenWISP Utils

[changelog]
# changelog header
header = """
Changelog
=========

All notable changes to this project will be documented in this file.

"""
# template for the changelog body
# Using ReStructuredText format to match existing CHANGES.rst
body = """
{% for group, commits in commits | group_by(attribute="group") -%}
{% if group -%}
{{ group }}
~~~~~~~~~~~~

{% for commit in commits -%}
- {{ commit.message | trim | upper_first }}{% if commit.breaking %} **BREAKING CHANGE**{% endif %}
{% endfor %}

{% endif -%}
{% endfor -%}
"""
# remove the leading and trailing whitespace from the template
trim = true
# changelog footer
footer = """
<!-- generated by git-cliff -->
"""

[git]
# parse the commits based on https://www.conventionalcommits.org
conventional_commits = false
# filter out the commits that are not conventional
filter_unconventional = false
# process each line of a commit as an individual commit
split_commits = false
# regex for preprocessing the commit messages
commit_preprocessors = [
    # Add links to issues
    { pattern = '#([0-9]+)', replace = "[#${1}](https://github.com/openwisp/openwisp-utils/issues/${1})"},
    # Clean up common patterns
    { pattern = '\s*\n\s*', replace = " "},
]
# regex for parsing and grouping commits
commit_parsers = [
    # Skip patterns - these commits should not appear in changelog
    { message = "^\\[skip changelog\\]", skip = true },
    { message = "^\\[skip\\]", skip = true },
    { message = "^\\[ci\\]", skip = true },
    { message = "^\\[qa\\]", skip = true },
    { message = "^\\[chores\\]", skip = true },
    { message = "^\\[chore\\]", skip = true },
    { message = "^\\[tests\\]", skip = true },
    { message = "^\\[test\\]", skip = true },
    { message = "^Merge ", skip = true },
    { message = "^merge ", skip = true },
    
    # Breaking changes (must come before non-breaking variants)
    { message = "^\\[feature!\\]", group = "Features", breaking = true },
    { message = "^\\[change!\\]", group = "Changes", breaking = true },
    { message = "^\\[fix!\\]", group = "Bugfixes", breaking = true },
    { message = "^\\[bugfix!\\]", group = "Bugfixes", breaking = true },
    
    # Features
    { message = "^\\[feature\\]", group = "Features" },
    { message = "^\\[feat\\]", group = "Features" },
    
    # Changes (backward compatible and incompatible)
    { message = "^\\[change\\]", group = "Changes" },
    
    # Dependencies
    { message = "^\\[deps\\]", group = "Dependencies" },
    { message = "^\\[dep\\]", group = "Dependencies" },
    { message = "^\\[dependencies\\]", group = "Dependencies" },
    
    # Bugfixes - broad patterns to catch various fix formats
    { message = "^\\[bugfix\\]", group = "Bugfixes" },
    { message = "^\\[fix\\]", group = "Bugfixes" },
    { message = "^\\[fix:", group = "Bugfixes" },
    
    # Utils and admin (could be features or changes depending on context)
    { message = "^\\[utils\\]", group = "Features" },
    { message = "^\\[admin\\]", group = "Features" },
    
    # Catch any other bracketed commits as miscellaneous
    { message = "^\\[.*\\]", group = "Other" },
]
# protect breaking changes from being skipped due to matching a skipping commit_parser
protect_breaking_commits = true
# filter out the commits that are not matched by commit parsers
filter_commits = false
# glob pattern for matching git tags
tag_pattern = "[0-9]*"
# regex for skipping tags
skip_tags = ".*-rc.*|.*-beta.*|.*-alpha.*"
# regex for ignoring tags
ignore_tags = ""
# sort the tags topologically
topo_order = false
# sort the commits inside sections by oldest/newest order
sort_commits = "oldest"
# limit the number of commits included in the changelog.
# limit_commits = 42